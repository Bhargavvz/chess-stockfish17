{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\adepu\\\\OneDrive\\\\Desktop\\\\stockfish\\\\chess-app\\\\src\\\\components\\\\ChessGame.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport { Chess } from 'chess.js';\nimport { Chessboard } from 'react-chessboard';\nimport { toast } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\nimport ChessAI from '../utils/chessAI';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ChessGame = ({\n  playerColor,\n  searchDepth = 15\n}) => {\n  _s();\n  const [game, setGame] = useState(new Chess());\n  const [chessAI, setChessAI] = useState(null);\n  const [isThinking, setIsThinking] = useState(false);\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [lastMove, setLastMove] = useState(null);\n  const [gameStatus, setGameStatus] = useState('');\n  const [engineReady, setEngineReady] = useState(false);\n  const [selectedSquare, setSelectedSquare] = useState(null);\n  const [possibleMoves, setPossibleMoves] = useState([]);\n  const [predictions, setPredictions] = useState([]);\n\n  // Refs to avoid stale closures in callbacks\n  const gameRef = useRef();\n  gameRef.current = game;\n\n  // Initialize Chess AI\n  useEffect(() => {\n    const ai = new ChessAI();\n    ai.onReady(() => {\n      setEngineReady(true);\n      toast.success('Chess engine ready!', {\n        autoClose: 2000\n      });\n    });\n    ai.init();\n    ai.setSearchDepth(searchDepth);\n    setChessAI(ai);\n    return () => {\n      if (ai) {\n        ai.terminate();\n      }\n    };\n  }, [searchDepth]);\n\n  // Update game status\n  useEffect(() => {\n    if (game.isGameOver()) {\n      if (game.isCheckmate()) {\n        const winner = game.turn() === 'w' ? 'Black' : 'White';\n        setGameStatus(`Checkmate! ${winner} wins.`);\n        toast.success(`Checkmate! ${winner} wins.`, {\n          autoClose: 5000\n        });\n      } else if (game.isDraw()) {\n        const reason = game.isStalemate() ? 'Stalemate' : game.isThreefoldRepetition() ? 'Threefold Repetition' : game.isInsufficientMaterial() ? 'Insufficient Material' : 'Fifty-move Rule';\n        setGameStatus(`Game Over! Draw: ${reason}`);\n        toast.info(reason, {\n          autoClose: 5000\n        });\n      }\n    } else {\n      setGameStatus(`${game.turn() === 'w' ? 'White' : 'Black'}'s turn`);\n    }\n\n    // Clear selected square and possible moves when game state changes\n    setSelectedSquare(null);\n    setPossibleMoves([]);\n\n    // Update the AI with the new position\n    if (chessAI && engineReady) {\n      chessAI.setPosition(game.fen());\n    }\n  }, [game, chessAI, engineReady]);\n\n  // Make a move on the board\n  const makeMove = useCallback(move => {\n    try {\n      const gameCopy = new Chess(gameRef.current.fen());\n      const result = gameCopy.move(move);\n      if (result) {\n        // Update move history\n        setMoveHistory(prevHistory => {\n          const newHistory = [...prevHistory];\n          newHistory.push(result);\n          return newHistory;\n        });\n\n        // Set last move for highlighting\n        setLastMove({\n          from: result.from,\n          to: result.to\n        });\n        setGame(gameCopy);\n\n        // Update the AI with the new position\n        if (chessAI) {\n          chessAI.makeMove(move);\n        }\n        return true;\n      }\n    } catch (e) {\n      console.error('Invalid move:', move, e);\n      toast.error(`Invalid move: ${move}`, {\n        autoClose: 2000\n      });\n      return false;\n    }\n    return false;\n  }, [chessAI]);\n\n  // Get AI's move\n  const getAIMove = useCallback(() => {\n    if (game.isGameOver() || !chessAI) return;\n    setIsThinking(true);\n    chessAI.getBestMove(bestMove => {\n      if (bestMove) {\n        makeMove(bestMove);\n        toast.info('AI made a move', {\n          autoClose: 1500\n        });\n      }\n      setIsThinking(false);\n    });\n  }, [chessAI, game, makeMove]);\n\n  // Get predicted best moves\n  const getPredictedMoves = useCallback(() => {\n    if (!engineReady || !chessAI || game.isGameOver()) return;\n\n    // Get all legal moves\n    const legalMoves = chessAI.getLegalMoves();\n\n    // Take up to 5 moves for predictions\n    const possiblePredictions = [];\n    for (let i = 0; i < Math.min(5, legalMoves.length); i++) {\n      // Simple evaluation based on piece values\n      const move = legalMoves[i];\n      let evaluation = 'Normal';\n      if (move.flags.includes('c')) {\n        evaluation = 'Good'; // Captures are usually good\n      } else if (move.san.includes('+')) {\n        evaluation = 'Good'; // Checks are usually good\n      } else if (move.flags.includes('p')) {\n        evaluation = 'Good'; // Promotions are good\n      } else if (Math.random() > 0.7) {\n        evaluation = 'Poor'; // Some moves are randomly marked as poor\n      }\n      possiblePredictions.push({\n        move: move,\n        evaluation: evaluation\n      });\n    }\n    setPredictions(possiblePredictions);\n  }, [engineReady, chessAI, game]);\n\n  // Handle square click for move selection\n  const handleSquareClick = square => {\n    // Don't allow moves during engine thinking or if game is over\n    if (isThinking || game.isGameOver()) return;\n\n    // Only allow moves if it's the player's turn\n    if (game.turn() === 'w' && playerColor === 'black' || game.turn() === 'b' && playerColor === 'white') {\n      return;\n    }\n\n    // If no square is selected yet, select this one if it has a piece of the current turn\n    if (!selectedSquare) {\n      const piece = game.get(square);\n      if (piece && piece.color === game.turn()) {\n        setSelectedSquare(square);\n\n        // Get possible moves for this piece\n        const moves = game.moves({\n          square: square,\n          verbose: true\n        });\n        setPossibleMoves(moves);\n      }\n    }\n    // If a square is already selected\n    else {\n      // Check if the clicked square is a valid move\n      const moveObj = possibleMoves.find(move => move.to === square);\n      if (moveObj) {\n        // Make the move\n        const success = makeMove({\n          from: selectedSquare,\n          to: square,\n          promotion: 'q' // Always promote to queen for simplicity\n        });\n        if (success) {\n          // Clear selection\n          setSelectedSquare(null);\n          setPossibleMoves([]);\n\n          // Get engine's move after a short delay\n          if (!game.isGameOver()) {\n            setTimeout(() => {\n              getAIMove();\n            }, 300);\n          }\n\n          // Update predictions\n          getPredictedMoves();\n        }\n      } else {\n        // If clicked on another own piece, select that one instead\n        const piece = game.get(square);\n        if (piece && piece.color === game.turn()) {\n          setSelectedSquare(square);\n\n          // Get possible moves for this piece\n          const moves = game.moves({\n            square: square,\n            verbose: true\n          });\n          setPossibleMoves(moves);\n        } else {\n          // If clicked on an invalid square, clear selection\n          setSelectedSquare(null);\n          setPossibleMoves([]);\n        }\n      }\n    }\n  };\n\n  // Make AI move if it's AI's turn at the start or after color change\n  useEffect(() => {\n    if (engineReady && !game.isGameOver() && (game.turn() === 'w' && playerColor === 'black' || game.turn() === 'b' && playerColor === 'white')) {\n      setTimeout(() => {\n        getAIMove();\n      }, 500);\n    }\n\n    // Update predictions whenever the game state changes\n    getPredictedMoves();\n  }, [engineReady, game, playerColor, getAIMove, getPredictedMoves]);\n\n  // Update search depth when it changes\n  useEffect(() => {\n    if (chessAI) {\n      chessAI.setSearchDepth(searchDepth);\n    }\n  }, [chessAI, searchDepth]);\n\n  // Format move history for display\n  const formattedHistory = useMemo(() => {\n    const formattedMoves = [];\n    for (let i = 0; i < moveHistory.length; i += 2) {\n      var _moveHistory$i, _moveHistory;\n      const moveNumber = Math.floor(i / 2) + 1;\n      const whiteMove = ((_moveHistory$i = moveHistory[i]) === null || _moveHistory$i === void 0 ? void 0 : _moveHistory$i.san) || '';\n      const blackMove = ((_moveHistory = moveHistory[i + 1]) === null || _moveHistory === void 0 ? void 0 : _moveHistory.san) || '';\n      formattedMoves.push({\n        moveNumber,\n        whiteMove,\n        blackMove\n      });\n    }\n    return formattedMoves;\n  }, [moveHistory]);\n\n  // Custom square styles for highlighting\n  const customSquareStyles = useMemo(() => {\n    const styles = {};\n\n    // Highlight last move\n    if (lastMove) {\n      styles[lastMove.from] = {\n        backgroundColor: 'rgba(255, 255, 0, 0.4)'\n      };\n      styles[lastMove.to] = {\n        backgroundColor: 'rgba(255, 255, 0, 0.4)'\n      };\n    }\n\n    // Highlight selected square\n    if (selectedSquare) {\n      styles[selectedSquare] = {\n        backgroundColor: 'rgba(0, 0, 255, 0.3)'\n      };\n\n      // Highlight possible moves\n      possibleMoves.forEach(move => {\n        // Green for empty squares, red for captures\n        const pieceOnTarget = game.get(move.to);\n        if (pieceOnTarget) {\n          styles[move.to] = {\n            backgroundColor: 'rgba(255, 0, 0, 0.5)'\n          }; // Red for captures\n        } else {\n          styles[move.to] = {\n            backgroundColor: 'rgba(0, 255, 0, 0.4)'\n          }; // Green for empty squares\n        }\n      });\n    }\n    return styles;\n  }, [lastMove, selectedSquare, possibleMoves, game]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"chess-game\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"board-container\",\n      children: /*#__PURE__*/_jsxDEV(Chessboard, {\n        position: game.fen(),\n        onSquareClick: handleSquareClick,\n        boardOrientation: playerColor,\n        customBoardStyle: {\n          borderRadius: '4px',\n          boxShadow: '0 5px 15px rgba(0, 0, 0, 0.5)'\n        },\n        customSquareStyles: customSquareStyles\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 310,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 309,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"game-info-panel\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"info-card\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: `status-indicator ${isThinking ? 'thinking' : game.isCheckmate() ? 'checkmate' : game.isDraw() ? 'draw' : 'active'}`,\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            children: \"Status:\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 325,\n            columnNumber: 13\n          }, this), isThinking ? 'AI is thinking...' : gameStatus]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 324,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 323,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"info-card\",\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"Move History\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 331,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"move-history\",\n          children: /*#__PURE__*/_jsxDEV(\"ul\", {\n            className: \"move-list\",\n            children: formattedHistory.map(move => /*#__PURE__*/_jsxDEV(React.Fragment, {\n              children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"move-number\",\n                children: [move.moveNumber, \".\"]\n              }, void 0, true, {\n                fileName: _jsxFileName,\n                lineNumber: 336,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"move-white\",\n                children: move.whiteMove\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 337,\n                columnNumber: 19\n              }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"move-black\",\n                children: move.blackMove\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 338,\n                columnNumber: 19\n              }, this)]\n            }, move.moveNumber, true, {\n              fileName: _jsxFileName,\n              lineNumber: 335,\n              columnNumber: 17\n            }, this))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 333,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 332,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 330,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"info-card\",\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          children: \"Predicted Best Moves\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 346,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"predictions-list\",\n          children: predictions.length > 0 ? /*#__PURE__*/_jsxDEV(\"ul\", {\n            className: \"prediction-items\",\n            children: predictions.map((prediction, index) => /*#__PURE__*/_jsxDEV(\"li\", {\n              className: `prediction-item ${prediction.evaluation === 'Good' ? 'good-move' : prediction.evaluation === 'Poor' ? 'poor-move' : ''}`,\n              onClick: () => {\n                if (!isThinking && game.turn() === (playerColor === 'white' ? 'w' : 'b')) {\n                  makeMove({\n                    from: prediction.move.from,\n                    to: prediction.move.to,\n                    promotion: prediction.move.promotion || 'q'\n                  });\n\n                  // Get engine's move after a short delay\n                  if (!game.isGameOver()) {\n                    setTimeout(() => {\n                      getAIMove();\n                    }, 300);\n                  }\n                }\n              },\n              children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"move-notation\",\n                children: prediction.move.san\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 371,\n                columnNumber: 21\n              }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                className: \"move-evaluation\",\n                children: prediction.evaluation\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 372,\n                columnNumber: 21\n              }, this)]\n            }, index, true, {\n              fileName: _jsxFileName,\n              lineNumber: 351,\n              columnNumber: 19\n            }, this))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 349,\n            columnNumber: 15\n          }, this) : /*#__PURE__*/_jsxDEV(\"p\", {\n            children: \"No predictions available\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 377,\n            columnNumber: 15\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 347,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 345,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 322,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 308,\n    columnNumber: 5\n  }, this);\n};\n_s(ChessGame, \"6VyQkkv1u7Zu/7IuJtcwFROdXBw=\");\n_c = ChessGame;\nexport default ChessGame;\nvar _c;\n$RefreshReg$(_c, \"ChessGame\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","useMemo","Chess","Chessboard","toast","ChessAI","jsxDEV","_jsxDEV","ChessGame","playerColor","searchDepth","_s","game","setGame","chessAI","setChessAI","isThinking","setIsThinking","moveHistory","setMoveHistory","lastMove","setLastMove","gameStatus","setGameStatus","engineReady","setEngineReady","selectedSquare","setSelectedSquare","possibleMoves","setPossibleMoves","predictions","setPredictions","gameRef","current","ai","onReady","success","autoClose","init","setSearchDepth","terminate","isGameOver","isCheckmate","winner","turn","isDraw","reason","isStalemate","isThreefoldRepetition","isInsufficientMaterial","info","setPosition","fen","makeMove","move","gameCopy","result","prevHistory","newHistory","push","from","to","e","console","error","getAIMove","getBestMove","bestMove","getPredictedMoves","legalMoves","getLegalMoves","possiblePredictions","i","Math","min","length","evaluation","flags","includes","san","random","handleSquareClick","square","piece","get","color","moves","verbose","moveObj","find","promotion","setTimeout","formattedHistory","formattedMoves","_moveHistory$i","_moveHistory","moveNumber","floor","whiteMove","blackMove","customSquareStyles","styles","backgroundColor","forEach","pieceOnTarget","className","children","position","onSquareClick","boardOrientation","customBoardStyle","borderRadius","boxShadow","fileName","_jsxFileName","lineNumber","columnNumber","map","Fragment","prediction","index","onClick","_c","$RefreshReg$"],"sources":["C:/Users/adepu/OneDrive/Desktop/stockfish/chess-app/src/components/ChessGame.js"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\r\nimport { Chess } from 'chess.js';\r\nimport { Chessboard } from 'react-chessboard';\r\nimport { toast } from 'react-toastify';\r\nimport 'react-toastify/dist/ReactToastify.css';\r\nimport ChessAI from '../utils/chessAI';\r\n\r\nconst ChessGame = ({ playerColor, searchDepth = 15 }) => {\r\n  const [game, setGame] = useState(new Chess());\r\n  const [chessAI, setChessAI] = useState(null);\r\n  const [isThinking, setIsThinking] = useState(false);\r\n  const [moveHistory, setMoveHistory] = useState([]);\r\n  const [lastMove, setLastMove] = useState(null);\r\n  const [gameStatus, setGameStatus] = useState('');\r\n  const [engineReady, setEngineReady] = useState(false);\r\n  const [selectedSquare, setSelectedSquare] = useState(null);\r\n  const [possibleMoves, setPossibleMoves] = useState([]);\r\n  const [predictions, setPredictions] = useState([]);\r\n  \r\n  // Refs to avoid stale closures in callbacks\r\n  const gameRef = useRef();\r\n  gameRef.current = game;\r\n\r\n  // Initialize Chess AI\r\n  useEffect(() => {\r\n    const ai = new ChessAI();\r\n    \r\n    ai.onReady(() => {\r\n      setEngineReady(true);\r\n      toast.success('Chess engine ready!', {\r\n        autoClose: 2000\r\n      });\r\n    });\r\n    \r\n    ai.init();\r\n    ai.setSearchDepth(searchDepth);\r\n    setChessAI(ai);\r\n    \r\n    return () => {\r\n      if (ai) {\r\n        ai.terminate();\r\n      }\r\n    };\r\n  }, [searchDepth]);\r\n\r\n  // Update game status\r\n  useEffect(() => {\r\n    if (game.isGameOver()) {\r\n      if (game.isCheckmate()) {\r\n        const winner = game.turn() === 'w' ? 'Black' : 'White';\r\n        setGameStatus(`Checkmate! ${winner} wins.`);\r\n        toast.success(`Checkmate! ${winner} wins.`, {\r\n          autoClose: 5000\r\n        });\r\n      } else if (game.isDraw()) {\r\n        const reason = game.isStalemate() ? 'Stalemate' : \r\n                      game.isThreefoldRepetition() ? 'Threefold Repetition' : \r\n                      game.isInsufficientMaterial() ? 'Insufficient Material' : \r\n                      'Fifty-move Rule';\r\n        setGameStatus(`Game Over! Draw: ${reason}`);\r\n        toast.info(reason, {\r\n          autoClose: 5000\r\n        });\r\n      }\r\n    } else {\r\n      setGameStatus(`${game.turn() === 'w' ? 'White' : 'Black'}'s turn`);\r\n    }\r\n    \r\n    // Clear selected square and possible moves when game state changes\r\n    setSelectedSquare(null);\r\n    setPossibleMoves([]);\r\n    \r\n    // Update the AI with the new position\r\n    if (chessAI && engineReady) {\r\n      chessAI.setPosition(game.fen());\r\n    }\r\n  }, [game, chessAI, engineReady]);\r\n\r\n  // Make a move on the board\r\n  const makeMove = useCallback((move) => {\r\n    try {\r\n      const gameCopy = new Chess(gameRef.current.fen());\r\n      const result = gameCopy.move(move);\r\n      \r\n      if (result) {\r\n        // Update move history\r\n        setMoveHistory(prevHistory => {\r\n          const newHistory = [...prevHistory];\r\n          newHistory.push(result);\r\n          return newHistory;\r\n        });\r\n        \r\n        // Set last move for highlighting\r\n        setLastMove({\r\n          from: result.from,\r\n          to: result.to\r\n        });\r\n        \r\n        setGame(gameCopy);\r\n        \r\n        // Update the AI with the new position\r\n        if (chessAI) {\r\n          chessAI.makeMove(move);\r\n        }\r\n        \r\n        return true;\r\n      }\r\n    } catch (e) {\r\n      console.error('Invalid move:', move, e);\r\n      toast.error(`Invalid move: ${move}`, {\r\n        autoClose: 2000\r\n      });\r\n      return false;\r\n    }\r\n    return false;\r\n  }, [chessAI]);\r\n\r\n  // Get AI's move\r\n  const getAIMove = useCallback(() => {\r\n    if (game.isGameOver() || !chessAI) return;\r\n    \r\n    setIsThinking(true);\r\n    \r\n    chessAI.getBestMove((bestMove) => {\r\n      if (bestMove) {\r\n        makeMove(bestMove);\r\n        toast.info('AI made a move', {\r\n          autoClose: 1500\r\n        });\r\n      }\r\n      setIsThinking(false);\r\n    });\r\n  }, [chessAI, game, makeMove]);\r\n\r\n  // Get predicted best moves\r\n  const getPredictedMoves = useCallback(() => {\r\n    if (!engineReady || !chessAI || game.isGameOver()) return;\r\n    \r\n    // Get all legal moves\r\n    const legalMoves = chessAI.getLegalMoves();\r\n    \r\n    // Take up to 5 moves for predictions\r\n    const possiblePredictions = [];\r\n    for (let i = 0; i < Math.min(5, legalMoves.length); i++) {\r\n      // Simple evaluation based on piece values\r\n      const move = legalMoves[i];\r\n      let evaluation = 'Normal';\r\n      \r\n      if (move.flags.includes('c')) {\r\n        evaluation = 'Good'; // Captures are usually good\r\n      } else if (move.san.includes('+')) {\r\n        evaluation = 'Good'; // Checks are usually good\r\n      } else if (move.flags.includes('p')) {\r\n        evaluation = 'Good'; // Promotions are good\r\n      } else if (Math.random() > 0.7) {\r\n        evaluation = 'Poor'; // Some moves are randomly marked as poor\r\n      }\r\n      \r\n      possiblePredictions.push({\r\n        move: move,\r\n        evaluation: evaluation\r\n      });\r\n    }\r\n    \r\n    setPredictions(possiblePredictions);\r\n  }, [engineReady, chessAI, game]);\r\n\r\n  // Handle square click for move selection\r\n  const handleSquareClick = (square) => {\r\n    // Don't allow moves during engine thinking or if game is over\r\n    if (isThinking || game.isGameOver()) return;\r\n    \r\n    // Only allow moves if it's the player's turn\r\n    if ((game.turn() === 'w' && playerColor === 'black') ||\r\n        (game.turn() === 'b' && playerColor === 'white')) {\r\n      return;\r\n    }\r\n    \r\n    // If no square is selected yet, select this one if it has a piece of the current turn\r\n    if (!selectedSquare) {\r\n      const piece = game.get(square);\r\n      if (piece && piece.color === game.turn()) {\r\n        setSelectedSquare(square);\r\n        \r\n        // Get possible moves for this piece\r\n        const moves = game.moves({ \r\n          square: square, \r\n          verbose: true \r\n        });\r\n        \r\n        setPossibleMoves(moves);\r\n      }\r\n    } \r\n    // If a square is already selected\r\n    else {\r\n      // Check if the clicked square is a valid move\r\n      const moveObj = possibleMoves.find(move => move.to === square);\r\n      \r\n      if (moveObj) {\r\n        // Make the move\r\n        const success = makeMove({\r\n          from: selectedSquare,\r\n          to: square,\r\n          promotion: 'q' // Always promote to queen for simplicity\r\n        });\r\n        \r\n        if (success) {\r\n          // Clear selection\r\n          setSelectedSquare(null);\r\n          setPossibleMoves([]);\r\n          \r\n          // Get engine's move after a short delay\r\n          if (!game.isGameOver()) {\r\n            setTimeout(() => {\r\n              getAIMove();\r\n            }, 300);\r\n          }\r\n          \r\n          // Update predictions\r\n          getPredictedMoves();\r\n        }\r\n      } else {\r\n        // If clicked on another own piece, select that one instead\r\n        const piece = game.get(square);\r\n        if (piece && piece.color === game.turn()) {\r\n          setSelectedSquare(square);\r\n          \r\n          // Get possible moves for this piece\r\n          const moves = game.moves({ \r\n            square: square, \r\n            verbose: true \r\n          });\r\n          \r\n          setPossibleMoves(moves);\r\n        } else {\r\n          // If clicked on an invalid square, clear selection\r\n          setSelectedSquare(null);\r\n          setPossibleMoves([]);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Make AI move if it's AI's turn at the start or after color change\r\n  useEffect(() => {\r\n    if (engineReady && \r\n        !game.isGameOver() && \r\n        ((game.turn() === 'w' && playerColor === 'black') ||\r\n         (game.turn() === 'b' && playerColor === 'white'))) {\r\n      setTimeout(() => {\r\n        getAIMove();\r\n      }, 500);\r\n    }\r\n    \r\n    // Update predictions whenever the game state changes\r\n    getPredictedMoves();\r\n  }, [engineReady, game, playerColor, getAIMove, getPredictedMoves]);\r\n\r\n  // Update search depth when it changes\r\n  useEffect(() => {\r\n    if (chessAI) {\r\n      chessAI.setSearchDepth(searchDepth);\r\n    }\r\n  }, [chessAI, searchDepth]);\r\n\r\n  // Format move history for display\r\n  const formattedHistory = useMemo(() => {\r\n    const formattedMoves = [];\r\n    for (let i = 0; i < moveHistory.length; i += 2) {\r\n      const moveNumber = Math.floor(i / 2) + 1;\r\n      const whiteMove = moveHistory[i]?.san || '';\r\n      const blackMove = moveHistory[i + 1]?.san || '';\r\n      formattedMoves.push({ moveNumber, whiteMove, blackMove });\r\n    }\r\n    return formattedMoves;\r\n  }, [moveHistory]);\r\n\r\n  // Custom square styles for highlighting\r\n  const customSquareStyles = useMemo(() => {\r\n    const styles = {};\r\n    \r\n    // Highlight last move\r\n    if (lastMove) {\r\n      styles[lastMove.from] = { backgroundColor: 'rgba(255, 255, 0, 0.4)' };\r\n      styles[lastMove.to] = { backgroundColor: 'rgba(255, 255, 0, 0.4)' };\r\n    }\r\n    \r\n    // Highlight selected square\r\n    if (selectedSquare) {\r\n      styles[selectedSquare] = { backgroundColor: 'rgba(0, 0, 255, 0.3)' };\r\n      \r\n      // Highlight possible moves\r\n      possibleMoves.forEach(move => {\r\n        // Green for empty squares, red for captures\r\n        const pieceOnTarget = game.get(move.to);\r\n        if (pieceOnTarget) {\r\n          styles[move.to] = { backgroundColor: 'rgba(255, 0, 0, 0.5)' }; // Red for captures\r\n        } else {\r\n          styles[move.to] = { backgroundColor: 'rgba(0, 255, 0, 0.4)' }; // Green for empty squares\r\n        }\r\n      });\r\n    }\r\n    \r\n    return styles;\r\n  }, [lastMove, selectedSquare, possibleMoves, game]);\r\n\r\n  return (\r\n    <div className=\"chess-game\">\r\n      <div className=\"board-container\">\r\n        <Chessboard\r\n          position={game.fen()}\r\n          onSquareClick={handleSquareClick}\r\n          boardOrientation={playerColor}\r\n          customBoardStyle={{\r\n            borderRadius: '4px',\r\n            boxShadow: '0 5px 15px rgba(0, 0, 0, 0.5)'\r\n          }}\r\n          customSquareStyles={customSquareStyles}\r\n        />\r\n      </div>\r\n      \r\n      <div className=\"game-info-panel\">\r\n        <div className=\"info-card\">\r\n          <div className={`status-indicator ${isThinking ? 'thinking' : game.isCheckmate() ? 'checkmate' : game.isDraw() ? 'draw' : 'active'}`}>\r\n            <span>Status:</span> \r\n            {isThinking ? 'AI is thinking...' : gameStatus}\r\n          </div>\r\n        </div>\r\n        \r\n        <div className=\"info-card\">\r\n          <h3>Move History</h3>\r\n          <div className=\"move-history\">\r\n            <ul className=\"move-list\">\r\n              {formattedHistory.map((move) => (\r\n                <React.Fragment key={move.moveNumber}>\r\n                  <span className=\"move-number\">{move.moveNumber}.</span>\r\n                  <span className=\"move-white\">{move.whiteMove}</span>\r\n                  <span className=\"move-black\">{move.blackMove}</span>\r\n                </React.Fragment>\r\n              ))}\r\n            </ul>\r\n          </div>\r\n        </div>\r\n        \r\n        <div className=\"info-card\">\r\n          <h3>Predicted Best Moves</h3>\r\n          <div className=\"predictions-list\">\r\n            {predictions.length > 0 ? (\r\n              <ul className=\"prediction-items\">\r\n                {predictions.map((prediction, index) => (\r\n                  <li \r\n                    key={index} \r\n                    className={`prediction-item ${prediction.evaluation === 'Good' ? 'good-move' : prediction.evaluation === 'Poor' ? 'poor-move' : ''}`}\r\n                    onClick={() => {\r\n                      if (!isThinking && game.turn() === (playerColor === 'white' ? 'w' : 'b')) {\r\n                        makeMove({\r\n                          from: prediction.move.from,\r\n                          to: prediction.move.to,\r\n                          promotion: prediction.move.promotion || 'q'\r\n                        });\r\n                        \r\n                        // Get engine's move after a short delay\r\n                        if (!game.isGameOver()) {\r\n                          setTimeout(() => {\r\n                            getAIMove();\r\n                          }, 300);\r\n                        }\r\n                      }\r\n                    }}\r\n                  >\r\n                    <span className=\"move-notation\">{prediction.move.san}</span>\r\n                    <span className=\"move-evaluation\">{prediction.evaluation}</span>\r\n                  </li>\r\n                ))}\r\n              </ul>\r\n            ) : (\r\n              <p>No predictions available</p>\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ChessGame; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}